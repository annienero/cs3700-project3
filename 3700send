#!/usr/bin/python -u
#
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json

MSG_SIZE = 1500
DATA_SIZE = 1000
TIMEOUT = 30
SEQUENCE = 0
RTO = 1
SLIDING_WINDOW = 200

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(TIMEOUT)

#setup bookkeeping
inFlightCount = 0
packetsInFlight = {}
RttSamples = []

def log(string):
  sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

def send_next_packet():
  global SEQUENCE
  global inFlightCount
  global packetsInFlight

  data = sys.stdin.read(DATA_SIZE)
  if (len(data) > 0):
    msgObj = {"sequence": SEQUENCE, "data": data, "eof": False}
    msg = json.dumps(msgObj)
    SEQUENCE += len(data)

    if sock.sendto(msg, dest) < len(msg):
      log("[error] unable to fully send packet")
    else:
      log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
      packetsInFlight[msgObj['sequence']] = (msg, time.time(), False) #pretty sure this give the current time
      inFlightCount += 1
    return True
  else:
    return False

# Send first packet
send_next_packet()

#helper that retransmits any packets that have timed out (were sent RTO or more seconds ago)
def maybeRetransmit():
  global packetsInFlight
  for key in packetsInFlight:
    value = packetsInFlight[key]
    msg = value[0] #first value of tuple is the raw message string to send, complete with headers and data
    timeSent = value[1] #second value of tuple is time sent. Time is the number of seconds past the epoch
    timeElapsed = time.time() - timeSent
    if timeElapsed >= RTO:
      #retransmiit and update the time sent
      log("timeElapsed = " + str(timeElapsed))
      if sock.sendto(msg, dest) < len(msg):
        log("[error] unable to fully send packet")
      else:
        log("[retransmit packet] " + str(key))
        packetsInFlight[key] = (msg, time.time(), True)

#takes a sequence number and retransmits all unacked packets before it
def fastRetransmit(seqNumber):
  global packetsInFlight
  curSeq = seqNumber
  while packetsInFlight.has_key(curSeq):
    #retrnsmit that packet
    msg = packetsInFlight[curSeq][0]
    if sock.sendto(msg, dest) < len(msg):
      log("[error] unable to fully send packet")
    else:
      log("[fast retransmit packet] " + msg)
      packetsInFlight[curSeq] = (msg, time.time(), True)
    curSeq -= DATA_SIZE

#updates rttsamples and rto with a new sample of round trip time
def updateRTO(rttSample):
  global RttSamples
  global RTO
  RttSamples += rttSample
  sampleSum = 0
  for sample in RttSamples:
    sampleSum += sample
  RTO = 2*(sampleSum/len(RttSamples))
  log("updated RTO to be: " + str(RTO) + ", new sample was: " + str(rttSample))

#helper that does a non-blocking receive, checks for ack, and modifies packetsInFlight as necessary
def listenForAck():
  global packetsInFlight
  global inFlightCount
  readable, writeable, exceptional = select.select([sock], [], [], 0) #writeable and exceptional are not used
  if len(readable) > 0: #if the socket is readable, read it
    result = sock.recvfrom(MSG_SIZE)
    (data, addr) = result
    log("data is" + data)
    try:
      decoded = json.loads(data)
      if decoded['ack'] == 0 or decoded['ack']: #if it's an ack
        log("[recv ack] " + str(decoded['ack']))
        #log("length of the data being acked: " + str(len(json.loads(packetsInFlight[decoded['ack']][0])['data'])))
        if len(json.loads(packetsInFlight[decoded['ack']][0])['data']) == decoded['length']:
          #retransmit any unacked packets we can find with ower sequence numbers
          fastRetransmit(decoded['ack'])
          #remove the entry for his ACK's sequence number in packetsInFlight
	  temp = packetsInFlight.pop(decoded['ack'], None)
          if not temp:
	    log("ERROR: Tried to remove an entry in packetsInFlight that does not exist")
          else:
            inFlightCount -= 1
            #update RTO with this new information
            targetEntry = packetsInFlight[decoded['ack']]
            timeSent = targetEntry[1]
            wasRetransmitted = targetEntry[2]
            if not wasRetransmitted:
              timeTaken = time.time() - timeSent
              updateRTO(timeTaken)
    except (ValueError, KeyError, TypeError):
      log("[recv corrupt packet]")
# --------------------

while True:
  listenForAck() #check for acks and process any we find
  if inFlightCount < SLIDING_WINDOW: #if we haven't filled the sliding window yet, send another packet
    if (not send_next_packet()) and (not bool(packetsInFlight)):
        log("we think we're done sending and receiving acks")
	break
  maybeRetransmit() #retransmit any packets that have timed out


finalMsgObj = {"eof": True, "data": "", "sequence": SEQUENCE, "ack": False}
finalMsg = json.dumps(finalMsgObj)

for i in range(0, 32):
  sock.sendto(finalMsg, dest)

sys.exit(0)
